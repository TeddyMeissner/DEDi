from SparseJaxAD.Coloring import StarColoring1,StarColoring2,D2Coloring
from SparseJaxAD.MatrixToGraph import sparse_matrix_to_graph
from jax.experimental.sparse import BCOO
from typing import Callable, Tuple
import jax, jax.numpy as jnp


def SparseHessian(        
        fun: Callable,
        sparse_hessian_args: Tuple[jnp.ndarray, jnp.ndarray, BCOO]
) -> Callable:
    """
    Generates a function to compute the sparse Hessian matrix of a given function using JAX.

    Parameters:
        fun (Callable): The target function for which the sparse Hessian is to be computed. This function
            should accept inputs in the form `fun(x, *args)`, where `x` is the point at which the Hessian
            is computed, and `*args` are any additional arguments the function requires.
        sparse_hessian_args (Tuple): A tuple containing the precomputed components for sparse Hessian
            computation. Should be generated by get_sparse_hessian_args function. 

    Returns:
        Callable: A function `SpHess` that computes the sparse Hessian matrix of `fun` at a given point `x`.
            It accepts the point `x` and any additional arguments `*args,**kwargs` required by `fun`, returning
            the sparse Hessian matrix as a JAX BCOO object.
    """

    projection_matrix,colored_index, indices = sparse_hessian_args

    _len = jnp.shape(projection_matrix)[1]
    # indices = Sparse_Adjecency_mat.indices.astype(jnp.int32)

    def SpHess(x,*args,**kwargs):
        data = vmap_hvp(fun,x,projection_matrix.astype(x.dtype),*args,**kwargs)[*colored_index]
        return BCOO((data,indices),shape = (_len,_len))

    return SpHess



def SparseJacobian(
        fun: Callable,
        sparse_jac_args: Tuple[jnp.ndarray, jnp.ndarray, BCOO]
) -> Callable:
    """
    Generates a function to compute the sparse Jacobian matrix of a given function using JAX.

    Parameters:
        fun (Callable): The target function for which the sparse Jacobian is to be computed. This function
            should accept inputs in the form `fun(x, *args)`, where `x` is the point at which the Hessian
            is computed, and `*args` are any additional arguments the function requires.
        sparse_jac_args (Tuple): A tuple containing the precomputed components for sparse Jacobian
            computation. Should be generated by get_sparse_jac_args function. 

    Returns:
        Callable: A function `SpJac` that computes the sparse Jacobian matrix of `fun` at a given point `x`.
            It accepts the point `x` and any additional arguments `*args,**kwargs` required by `fun`, returning
            the sparse Jacobain matrix as a JAX BCOO object.
    """
    projection_matrix,colored_index,Sparse_Adjecency_mat = sparse_jac_args

    _shape = Sparse_Adjecency_mat.shape
    indices = Sparse_Adjecency_mat.indices

    def SpJac(x,*args,**kwargs):
        data = vmap_jvp(fun,x,projection_matrix.astype(x.dtype),*args,**kwargs)[*colored_index]
        return BCOO((data,indices),shape = _shape )

    return SpJac


def get_sparse_hessian_args(
    adjacency_mat: BCOO,
    coloring: str = "Star2",
    colorvec = None,
    return_vec = False
) -> Tuple[jnp.ndarray, jnp.ndarray, BCOO]:
    """
    Prepares arguments for sparse Hessian computation using graph coloring.

    Parameters:
        adjacency_mat (BCOO): The adjacency matrix of the graph,
            either in scipy sparse format or as a JAX BCOO object.
        coloring (str, optional): The coloring method to use. Defaults to "Star1" -- see Coloring.

    Returns:
        Tuple[np.ndarray, np.ndarray, BCOO]: A tuple containing the projection matrix,
            colored indices, and the adjacency matrix in BCOO format.
    """

    if colorvec is None:
        colorvec = get_hess_color_vec(adjacency_mat,coloring = coloring)

    ncolors = jnp.unique(colorvec).size

    projection_matrix = jnp.arange(ncolors)[:, None] == colorvec[None, :]

    #Due to symmetry some entries are attached to multiple colors, find overlapping colors
    overlapping_colors_idx = projection_matrix@adjacency_mat
    row, col = adjacency_mat.indices.T
    colored_index_with_overlap = (colorvec[row], col)
    num_colors_per_entry = overlapping_colors_idx[colored_index_with_overlap]
    non_unique_entries = jnp.squeeze(jnp.argwhere(num_colors_per_entry !=1))

    # If entry is attached to multiple colors, switch to one with no overlapping computations
    row,col = row.at[non_unique_entries].set(col[non_unique_entries]),col.at[non_unique_entries].set(row[non_unique_entries])
    colored_index = (colorvec[row], col)
    indices = adjacency_mat.indices.astype(jnp.int32)

    if return_vec:
        return projection_matrix,colored_index,indices,colorvec
    else:
        return projection_matrix,colored_index,indices

def get_hess_color_vec(adjacency_mat: BCOO,
                  coloring: str = "Star2"):
    
    graph = sparse_matrix_to_graph(adjacency_mat) 
    if coloring == "Star1":
        colorvec = StarColoring1(graph)
    elif  coloring == "Star2":
        colorvec = StarColoring2(graph)
    else:
        raise ValueError("Coloring method not defined")
    
    return colorvec
    

def get_sparse_jac_args(
    adjacency_mat: BCOO,
    coloring: str = "D2"
) -> Tuple[jnp.ndarray, jnp.ndarray, BCOO]:
    """
    Prepares arguments for sparse Jacobian computation using graph coloring.

    Parameters:
        adjacency_mat (BCOO): The adjacency matrix of the graph,
            either in scipy sparse format or as a JAX BCOO object.
        coloring (str, optional): The coloring method to use, defaults to "D2" -- see Coloring.

    Returns:
        Tuple[np.ndarray, np.ndarray, BCOO]: A tuple containing the projection matrix,
            colored indices, and the adjacency matrix in BCOO format.
    """

    graph = sparse_matrix_to_graph(adjacency_mat,graph_kind="directed") 

    if coloring == "D2":
        colorvec = D2Coloring(graph)
    else:
        raise ValueError("Coloring method not defined")

    ncolors = jnp.unique(colorvec).size

    projection_matrix = jnp.arange(ncolors)[:, None] == colorvec[None, :]

    row, col = adjacency_mat.indices.T
    colored_index = (colorvec[row], col)

    return projection_matrix,colored_index,adjacency_mat



### Functions below perform the hessian and jacobain vector products as defined in 
### Jax AutoDiff Cookbook https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html

def hvp(f, x, v):
    return jax.jvp(jax.grad(f), (x,), (v,))[1]


def vmap_hvp(f, x, v, *args, **kwargs):
    hvp_fun = lambda v: hvp(lambda x: f(x, *args, **kwargs), x, v)
    return jax.vmap(hvp_fun)(v)


def vmap_jvp(f, x, v, *args,**kwargs):
    jvp_fun = lambda tangents: jax.jvp(lambda x: f(x, *args,**kwargs), (x,), (tangents,))[1]
    return jax.vmap(jvp_fun)(v)





